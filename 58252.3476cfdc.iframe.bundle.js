"use strict";(globalThis.webpackChunkmetamask_crx=globalThis.webpackChunkmetamask_crx||[]).push([[58252],{"./node_modules/@metamask/assets-controllers/node_modules/multiformats/dist/src/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{function equals(aa,bb){if(aa===bb)return!0;if(aa.byteLength!==bb.byteLength)return!1;for(let ii=0;ii<aa.byteLength;ii++)if(aa[ii]!==bb[ii])return!1;return!0}function coerce(o){if(o instanceof Uint8Array&&"Uint8Array"===o.constructor.name)return o;if(o instanceof ArrayBuffer)return new Uint8Array(o);if(ArrayBuffer.isView(o))return new Uint8Array(o.buffer,o.byteOffset,o.byteLength);throw Error("Unknown type, must be binary type")}__webpack_require__.d(__webpack_exports__,{CID:()=>CID}),new Uint8Array(0);var src=function base(ALPHABET,name){if(ALPHABET.length>=255)throw TypeError("Alphabet too long");for(var BASE_MAP=new Uint8Array(256),j=0;j<BASE_MAP.length;j++)BASE_MAP[j]=255;for(var i=0;i<ALPHABET.length;i++){var x=ALPHABET.charAt(i),xc=x.charCodeAt(0);if(255!==BASE_MAP[xc])throw TypeError(x+" is ambiguous");BASE_MAP[xc]=i}var BASE=ALPHABET.length,LEADER=ALPHABET.charAt(0),FACTOR=Math.log(BASE)/Math.log(256),iFACTOR=Math.log(256)/Math.log(BASE);function decodeUnsafe(source){if("string"!=typeof source)throw TypeError("Expected String");if(0===source.length)return new Uint8Array;var psz=0;if(" "!==source[0]){for(var zeroes=0,length=0;source[psz]===LEADER;)zeroes++,psz++;for(var size=(source.length-psz)*FACTOR+1>>>0,b256=new Uint8Array(size);source[psz];){var carry=BASE_MAP[source.charCodeAt(psz)];if(255===carry)return;for(var i=0,it3=size-1;(0!==carry||i<length)&&-1!==it3;it3--,i++)carry+=BASE*b256[it3]>>>0,b256[it3]=carry%256>>>0,carry=carry/256>>>0;if(0!==carry)throw Error("Non-zero carry");length=i,psz++}if(" "!==source[psz]){for(var it4=size-length;it4!==size&&0===b256[it4];)it4++;for(var vch=new Uint8Array(zeroes+(size-it4)),j=zeroes;it4!==size;)vch[j++]=b256[it4++];return vch}}}function decode(string){var buffer=decodeUnsafe(string);if(buffer)return buffer;throw Error(`Non-${name} character`)}return{encode:function encode(source){if(source instanceof Uint8Array||(ArrayBuffer.isView(source)?source=new Uint8Array(source.buffer,source.byteOffset,source.byteLength):Array.isArray(source)&&(source=Uint8Array.from(source))),!(source instanceof Uint8Array))throw TypeError("Expected Uint8Array");if(0===source.length)return"";for(var zeroes=0,length=0,pbegin=0,pend=source.length;pbegin!==pend&&0===source[pbegin];)pbegin++,zeroes++;for(var size=(pend-pbegin)*iFACTOR+1>>>0,b58=new Uint8Array(size);pbegin!==pend;){for(var carry=source[pbegin],i=0,it1=size-1;(0!==carry||i<length)&&-1!==it1;it1--,i++)carry+=256*b58[it1]>>>0,b58[it1]=carry%BASE>>>0,carry=carry/BASE>>>0;if(0!==carry)throw Error("Non-zero carry");length=i,pbegin++}for(var it2=size-length;it2!==size&&0===b58[it2];)it2++;for(var str=LEADER.repeat(zeroes);it2<size;++it2)str+=ALPHABET.charAt(b58[it2]);return str},decodeUnsafe:decodeUnsafe,decode:decode}};class Encoder{name;prefix;baseEncode;constructor(name,prefix,baseEncode){this.name=name,this.prefix=prefix,this.baseEncode=baseEncode}encode(bytes){if(bytes instanceof Uint8Array)return`${this.prefix}${this.baseEncode(bytes)}`;throw Error("Unknown type, must be binary type")}}class Decoder{name;prefix;baseDecode;prefixCodePoint;constructor(name,prefix,baseDecode){if(this.name=name,this.prefix=prefix,void 0===prefix.codePointAt(0))throw Error("Invalid prefix character");this.prefixCodePoint=prefix.codePointAt(0),this.baseDecode=baseDecode}decode(text){if("string"==typeof text){if(text.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(text.slice(this.prefix.length))}throw Error("Can only multibase decode strings")}or(decoder){return or(this,decoder)}}class ComposedDecoder{decoders;constructor(decoders){this.decoders=decoders}or(decoder){return or(this,decoder)}decode(input){let prefix=input[0],decoder=this.decoders[prefix];if(null!=decoder)return decoder.decode(input);throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function or(left,right){return new ComposedDecoder({...left.decoders??{[left.prefix]:left},...right.decoders??{[right.prefix]:right}})}class Codec{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(name,prefix,baseEncode,baseDecode){this.name=name,this.prefix=prefix,this.baseEncode=baseEncode,this.baseDecode=baseDecode,this.encoder=new Encoder(name,prefix,baseEncode),this.decoder=new Decoder(name,prefix,baseDecode)}encode(input){return this.encoder.encode(input)}decode(input){return this.decoder.decode(input)}}function from({name,prefix,encode,decode}){return new Codec(name,prefix,encode,decode)}function baseX({name,prefix,alphabet}){let{encode,decode}=src(alphabet,name);return from({prefix,name,encode,decode:text=>coerce(decode(text))})}function decode(string,alphabet,bitsPerChar,name){let codes={};for(let i=0;i<alphabet.length;++i)codes[alphabet[i]]=i;let end=string.length;for(;"="===string[end-1];)--end;let out=new Uint8Array(end*bitsPerChar/8|0),bits=0,buffer=0,written=0;for(let i=0;i<end;++i){let value=codes[string[i]];if(void 0===value)throw SyntaxError(`Non-${name} character`);buffer=buffer<<bitsPerChar|value,(bits+=bitsPerChar)>=8&&(bits-=8,out[written++]=255&buffer>>bits)}if(bits>=bitsPerChar||(255&buffer<<8-bits)!=0)throw SyntaxError("Unexpected end of data");return out}function encode(data,alphabet,bitsPerChar){let pad="="===alphabet[alphabet.length-1],mask=(1<<bitsPerChar)-1,out="",bits=0,buffer=0;for(let i=0;i<data.length;++i)for(buffer=buffer<<8|data[i],bits+=8;bits>bitsPerChar;)bits-=bitsPerChar,out+=alphabet[mask&buffer>>bits];if(0!==bits&&(out+=alphabet[mask&buffer<<bitsPerChar-bits]),pad)for(;(out.length*bitsPerChar&7)!=0;)out+="=";return out}function rfc4648({name,prefix,bitsPerChar,alphabet}){return from({prefix,name,encode:input=>encode(input,alphabet,bitsPerChar),decode:input=>decode(input,alphabet,bitsPerChar,name)})}let base32=rfc4648({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5});rfc4648({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),rfc4648({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),rfc4648({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),rfc4648({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),rfc4648({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),rfc4648({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),rfc4648({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),rfc4648({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});let base58btc=baseX({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"});function varint_encode(num,out,offset){out=out||[];for(var oldOffset=offset=offset||0;num>=0x80000000;)out[offset++]=255&num|128,num/=128;for(;-128&num;)out[offset++]=255&num|128,num>>>=7;return out[offset]=0|num,varint_encode.bytes=offset-oldOffset+1,out}function read(buf,offset){var b,res=0,offset=offset||0,shift=0,counter=offset,l=buf.length;do{if(counter>=l)throw read.bytes=0,RangeError("Could not decode varint");b=buf[counter++],res+=shift<28?(127&b)<<shift:(127&b)*Math.pow(2,shift),shift+=7}while(b>=128)return read.bytes=counter-offset,res}baseX({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});let vendor_varint={encode:varint_encode,decode:read,encodingLength:function(value){return value<128?1:value<16384?2:value<2097152?3:value<0x10000000?4:value<0x800000000?5:value<0x40000000000?6:value<0x2000000000000?7:value<0x100000000000000?8:value<0x8000000000000000?9:10}};function src_varint_decode(data,offset=0){return[vendor_varint.decode(data,offset),vendor_varint.decode.bytes]}function encodeTo(int,target,offset=0){return vendor_varint.encode(int,target,offset),target}function encodingLength(int){return vendor_varint.encodingLength(int)}function create(code,digest){let size=digest.byteLength,sizeOffset=encodingLength(code),digestOffset=sizeOffset+encodingLength(size),bytes=new Uint8Array(digestOffset+size);return encodeTo(code,bytes,0),encodeTo(size,bytes,sizeOffset),bytes.set(digest,digestOffset),new digest_Digest(code,size,digest,bytes)}function digest_decode(multihash){let bytes=coerce(multihash),[code,sizeOffset]=src_varint_decode(bytes),[size,digestOffset]=src_varint_decode(bytes.subarray(sizeOffset)),digest=bytes.subarray(sizeOffset+digestOffset);if(digest.byteLength!==size)throw Error("Incorrect length");return new digest_Digest(code,size,digest,bytes)}function digest_equals(a,b){return a===b||a.code===b.code&&a.size===b.size&&b.bytes instanceof Uint8Array&&equals(a.bytes,b.bytes)}class digest_Digest{code;size;digest;bytes;constructor(code,size,digest,bytes){this.code=code,this.size=size,this.digest=digest,this.bytes=bytes}}function format(link,base){let{bytes,version}=link;return 0===version?toStringV0(bytes,baseCache(link),base??base58btc.encoder):toStringV1(bytes,baseCache(link),base??base32.encoder)}let cache=new WeakMap;function baseCache(cid){let baseCache=cache.get(cid);if(null==baseCache){let baseCache=new Map;return cache.set(cid,baseCache),baseCache}return baseCache}class CID{code;version;multihash;bytes;"/";constructor(version,code,multihash,bytes){this.code=code,this.version=version,this.multihash=multihash,this.bytes=bytes,this["/"]=bytes}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{let{code,multihash}=this;if(code!==DAG_PB_CODE)throw Error("Cannot convert a non dag-pb CID to CIDv0");if(multihash.code!==SHA_256_CODE)throw Error("Cannot convert non sha2-256 multihash CID to CIDv0");return CID.createV0(multihash)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{let{code,digest}=this.multihash,multihash=create(code,digest);return CID.createV1(this.code,multihash)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(other){return CID.equals(this,other)}static equals(self,other){return null!=other&&self.code===other.code&&self.version===other.version&&digest_equals(self.multihash,other.multihash)}toString(base){return format(this,base)}toJSON(){return{"/":format(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(input){if(null==input)return null;if(input instanceof CID)return input;if(null!=input["/"]&&input["/"]===input.bytes||input.asCID===input){let{version,code,multihash,bytes}=input;return new CID(version,code,multihash,bytes??encodeCID(version,code,multihash.bytes))}if(!0!==input[cidSymbol])return null;{let{version,multihash,code}=input,digest=digest_decode(multihash);return CID.create(version,code,digest)}}static create(version,code,digest){if("number"!=typeof code)throw Error("String codecs are no longer supported");if(!(digest.bytes instanceof Uint8Array))throw Error("Invalid digest");switch(version){case 0:if(code===DAG_PB_CODE)return new CID(version,code,digest,digest.bytes);throw Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);case 1:{let bytes=encodeCID(version,code,digest.bytes);return new CID(version,code,digest,bytes)}default:throw Error("Invalid version")}}static createV0(digest){return CID.create(0,DAG_PB_CODE,digest)}static createV1(code,digest){return CID.create(1,code,digest)}static decode(bytes){let[cid,remainder]=CID.decodeFirst(bytes);if(0!==remainder.length)throw Error("Incorrect length");return cid}static decodeFirst(bytes){let specs=CID.inspectBytes(bytes),prefixSize=specs.size-specs.multihashSize,multihashBytes=coerce(bytes.subarray(prefixSize,prefixSize+specs.multihashSize));if(multihashBytes.byteLength!==specs.multihashSize)throw Error("Incorrect length");let digestBytes=multihashBytes.subarray(specs.multihashSize-specs.digestSize),digest=new digest_Digest(specs.multihashCode,specs.digestSize,digestBytes,multihashBytes);return[0===specs.version?CID.createV0(digest):CID.createV1(specs.codec,digest),bytes.subarray(specs.size)]}static inspectBytes(initialBytes){let offset=0,next=()=>{let[i,length]=src_varint_decode(initialBytes.subarray(offset));return offset+=length,i},version=next(),codec=DAG_PB_CODE;if(18===version?(version=0,offset=0):codec=next(),0!==version&&1!==version)throw RangeError(`Invalid CID version ${version}`);let prefixSize=offset,multihashCode=next(),digestSize=next(),size=offset+digestSize;return{version,codec,multihashCode,digestSize,multihashSize:size-prefixSize,size}}static parse(source,base){let[prefix,bytes]=parseCIDtoBytes(source,base),cid=CID.decode(bytes);if(0===cid.version&&"Q"!==source[0])throw Error("Version 0 CID string must not include multibase prefix");return baseCache(cid).set(prefix,source),cid}}function parseCIDtoBytes(source,base){switch(source[0]){case"Q":{let decoder=base??base58btc;return[base58btc.prefix,decoder.decode(`${base58btc.prefix}${source}`)]}case base58btc.prefix:{let decoder=base??base58btc;return[base58btc.prefix,decoder.decode(source)]}case base32.prefix:{let decoder=base??base32;return[base32.prefix,decoder.decode(source)]}default:if(null==base)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[source[0],base.decode(source)]}}function toStringV0(bytes,cache,base){let{prefix}=base;if(prefix!==base58btc.prefix)throw Error(`Cannot string encode V0 in ${base.name} encoding`);let cid=cache.get(prefix);if(null!=cid)return cid;{let cid=base.encode(bytes).slice(1);return cache.set(prefix,cid),cid}}function toStringV1(bytes,cache,base){let{prefix}=base,cid=cache.get(prefix);if(null!=cid)return cid;{let cid=base.encode(bytes);return cache.set(prefix,cid),cid}}let DAG_PB_CODE=112,SHA_256_CODE=18;function encodeCID(version,code,multihash){let codeOffset=encodingLength(version),hashOffset=codeOffset+encodingLength(code),bytes=new Uint8Array(hashOffset+multihash.byteLength);return encodeTo(version,bytes,0),encodeTo(code,bytes,codeOffset),bytes.set(multihash,hashOffset),bytes}let cidSymbol=Symbol.for("@ipld/js-cid/CID")}}]);